/*Дана схема старого лабиринта, нужно удалить минимальное число стен (вертикальных и горизонтальных),
 * чтобы внутреннее пространство лабиринта стало связным. Т.е. из любой клетки внутреннего пространства
 * можно было бы попасть в любую другую, двигаясь только в соседние клетки по вертикали или горизонтали, не пересекая стен.
Формат ввода

В первой строке входных данных записаны два целых числа n и m (1 ≤ n, m ≤ 50) — количество "строк"
и количество "столбцов" лабиринта.
Далее в (2n+1) строках записано описание лабиринта:
каждая строка содержит (2m+1) символов '+' (ASCII 43), '-' (ASCII 45), '|' (ASCII 124), '.' (ASCII 46);
первая и последняя строки задают горизонтальные границы лабиринта;
первый и последний столбец задают вертикальные границы лабиринта;
клетки с обеими четными координатами заполнены символами '.' (внутреннее пространство лабиринта);
клетки с обеими нечетными координатами заполнены символами '+' (служебные клетки);
клетки с одной четной и одной нечетной координатами содержат один из символов '.' (нет стены), '-' (горизонтальная стена),
'|' (вертикальная стена)
Пример входных данных:
2 3
+-+-+-+
|.|...|
+-+-+-+
|.|...|
+-+-+-+
*/

#include <iostream>
#include <vector>

using namespace std;

class Labyrinth{
public:
    int n, m;
    vector<vector<char>> v;

    Labyrinth(int n, int m): n{n}, m{m}{
        v.resize(2 * n + 1);
        for (int i = 0; i < 2 * n + 1; ++i){
            v[i].resize(2 * m + 1);
            for (int j = 0; j < 2 * m + 1; ++j)
                cin >> v[i][j];
        }
    }
    void fill(int x, int y){
        v[x][y] = '0';
        if (v[x][y - 1] == '.')
            fill(x, y - 1);
        if (v[x][y + 1] == '.')
            fill(x, y + 1);
        if (v[x - 1][y] == '.')
            fill(x - 1, y);
        if (v[x + 1][y] == '.')
            fill(x + 1, y);
    }
    void break_wall(int &x, int &y){
        x = y = -1;
        for (int i = 1; i < 2 * n; i += 2){
            for (int j = 1; j < 2 * m; j += 2){
                if (v[i][j] != '0')
                    continue;
                if (j > 1){
                    if (v[i][j - 1] == '|' && v[i][j - 2] == '.'){
                        x = i;
                        y = j - 1;
                        return;
                    }
                }
                if (j < 2 * m - 1){
                    if (v[i][j + 1] == '|' && v[i][j + 2] == '.'){
                        x = i;
                        y = j + 1;
                        return;
                    }
                }
                if (i > 1){
                    if (v[i - 1][j] == '-' && v[i - 2][j] == '.'){
                        x = i - 1;
                        y = j;
                        return;
                    }
                }
                if (i < 2 * n - 1){
                    if (v[i + 1][j] == '-' && v[i + 2][j] == '.'){
                        x = i + 1;
                        y = j;
                        return;
                    }
                }
            }
        }
    }
    void solve(){
        fill(1, 1);
        int x = 0, y = 0;
        break_wall(x, y);
        while (x != -1){
            v[x][y] = '.';
            fill(x, y);
            break_wall(x, y);
        }
        print();
    }
    void print(){
        for (auto &i : v){
            for (auto &j : i){
                if (j == '0')
                    cout << '.';
                else
                    cout << j;
            }
            cout << endl;
        }
    }
};

int main()
{
    int n = 0, m = 0;

    cin >> n >> m;
    Labyrinth L(n, m);
    L.solve();

    return 0;
}
