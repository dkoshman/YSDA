/*В этой задаче мы рассмотрим некоторый частный вид графов «гусениц».
 *  Граф «гусеница» состоит из цепочки из n вершин и дополнительных вершин,
 *  каждая из которых смежная одной из вершин на цепочке.
 *  Легко видеть, что такой граф можно задать последовательностью чисел d, d(i) — количество дополнительных вершин,
 *  смежных с i-й вершиной цепочки. Вершины цепочки пронумерованы от 1 до n от одного конца к другому.
Для заданного графа «гусеницы» подсчитайте количество подмножеств вершин, которые являются вершинным покрытие графа
(для любого ребра графа хотя бы один из его концов должен быть в подмножестве).
Обратите внимание, что речь не идет о минимизации количества вершин в множестве*/

#include <iostream>
#include <vector>
#include <cmath>

using namespace std;
using shlong = unsigned long long;
shlong MOD = 1000000007;

class Count{
public:
    int n;
    vector<int> v;
    vector<int> p2;
    vector<shlong> res;
    Count(int n, vector<int> v) : n{n}, v{v}
    {
        p2.resize(101);
        p2[0] = 1;
        for (int i = 1; i < 101; ++i)
            p2[i] = (p2[i - 1] * 2) % MOD;
        res.resize(n + 1);
        res[n - 1] = res[n] = 1;
        for (int i = n - 2; i >= 0; --i){
            res[i] = (p2[v[i]] * (res[i + 1] + res[i + 2])) % MOD;
        }
    }
};

int main()
{
    int n = 0;
    cin >> n;
    vector<int> v;
    v.resize(n);
    for (int i = 0; i < n; ++i)
        cin >> v[i];
    Count C(n, v);
    cout << ((C.res[0] + C.res[1]) % MOD) << endl;
    return 0;
}
